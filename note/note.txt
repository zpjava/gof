模式：
名称 
问题描述
 解决方案 (实现)
 模式评价

 
 =========================================
 http://www.uml.org.cn/sjms/201211023.asp
 http://entere.blogchina.com/1240842.html
 http://blog.csdn.net/column/details/pattern.html?page=1
 
 
 名称         ：单一职责
 定义         ：不要存在多于一个导致类变更的原因。（即一个类只负责一项职责。）
问题由来：类T负责两个不同的职责：职责P1，职责P2。当由于职责P1需求发生改变而需要修改类T时，有可能会导致原本运行正常的职责P2功能发生故障。
		   为什么会出现这种现象呢？因为有职责扩散。所谓职责扩散，就是因为某种原因，职责P被分化为粒度更细的职责P1和P2。
解决方案：遵循单一职责原则。分别建立两个类T1、T2，使T1完成职责P1功能，T2完成职责P2功能。这样，当修改类T1时，不会使职责P2发生故障风险；同理，当修改T2时，也不会使职责P1发生故障风险。
优点          ：可以降低类的复杂度，一个类只负责一项职责，其逻辑肯定要比负责多项职责简单的多；
		    提高类的可读性，提高系统的可维护性；
		    变更引起的风险降低，变更是必然的，如果单一职责原则遵守的好，当修改一个功能时，可以显著降低对其他功能的影响。
	
		    
名称          ：里氏替换
定义          ：所有引用基类的地方必须能透明地使用其子类的对象。		    
问题由来：有一功能P1，由类A完成。现需要将功能P1进行扩展，扩展后的功能为P，其中P由原有功能P1与新功能P2组成。新功能P由类A的子类B来完成，则子类B在完成新功能P2的同时，有可能会导致原有功能P1发生故障。
解决方案：当使用继承时，遵循里氏替换原则。类B继承类A时，除添加新的方法完成新增功能P2外，尽量不要重写父类A的方法，也尽量不要重载父类A的方法。
优点          ：（子类可以扩展父类的功能，但不能改变父类原有的功能。）
		    子类可以实现父类的抽象方法，但不能覆盖父类的非抽象方法。
		    子类中可以增加自己特有的方法。
		    当子类的方法重载父类的方法时，方法的前置条件（即方法的形参）要比父类方法的输入参数更宽松。
		    当子类的方法实现父类的抽象方法时，方法的后置条件（即方法的返回值）要比父类更严格。
后果          ：违反里氏替换原则，你写的代码出问题的几率将会大大增加。


名称          ：依赖倒置
定义          ：高层模块不应该依赖低层模块，二者都应该依赖其抽象；抽象不应该依赖细节；细节应该依赖抽象。 
		    问题由来：类A直接依赖类B，假如要将类A改为依赖类C，则必须通过修改类A的代码来达成。这种场景下，类A一般是高层模块，负责复杂的业务逻辑；类B和类C是低层模块，负责基本的原子操作；假如修改类A，会给程序带来不必要的风险。
		    依赖倒置原则的核心思想是面向接口编程		    
解决方案：将类A修改为依赖接口I，类B和类C各自实现接口I，类A通过接口I间接与类B或者类C发生联系，则会大大降低修改类A的几率。
分类          ：传递依赖关系有三种方式，以上的例子中使用的方法是接口传递，另外还有两种传递方式：构造方法传递和setter方法传递，相信用过Spring框架的，对依赖的传递方式一定不会陌生。
		    接口传递，构造方法传递，setter方法传递
实现          ：低层模块尽量都要有抽象类或接口，或者两者都有。
		    变量的声明类型尽量是抽象类或接口。
		    使用继承时遵循里氏替换原则。
		  （ 通过对频繁变化的原子细节做适当抽象，能降低修改核心业务逻辑的频率。前提是细节的变化不影响逻辑）
优点          ：依赖倒置原则的核心就是要我们面向接口编程		


名称          ：接口隔离（为依赖类定制服务）
定义          ：客户端不应该依赖它不需要的接口；一个类对另一个类的依赖应该建立在最小的接口上。	    
问题由来：类A通过接口I依赖类B，类C通过接口I依赖类D，如果接口I对于类A和类B来说不是最小接口，则类B和类D必须去实现他们不需要的方法。
解决方案：将臃肿的接口I拆分为独立的几个接口，类A和类C分别与他们需要的接口建立依赖关系。也就是采用接口隔离原则。
单一职责与接口隔离的区别：
		   其一，单一职责原则原注重的是职责；而接口隔离原则注重对接口依赖的隔离。
		   其二，单一职责原则主要是约束类，其次才是接口和方法，它针对的是程序中的实现和细节；而接口隔离原则主要约束接口接口，主要针对抽象，针对程序整体框架的构建。
实现          ：接口尽量小，但是要有限度。
		   为依赖接口的类定制服务，只暴露给调用的类它需要的方法，它不需要的方法则隐藏起来。只有专注地为一个模块提供定制服务，才能建立最小的依赖关系。
		   提高内聚，减少对外交互。使接口用最少的方法去完成最多的事情。		  
优点         ：在程序设计中，依赖几个专用的接口要比依赖一个综合的接口更灵活。接口是设计时对外部设定的“契约”，通过分散定义多个接口，可以预防外来变更的扩散，提高系统的灵活性和可维护性。  
后果          ：接口过于臃肿，依赖类中出现的很多无用的方法。


名称          ：迪米特-最少知道
定义          ： 一个对象应该对其他对象保持最少的了解。
问题由来：类与类之间的关系越密切，耦合度越大，当一个类发生改变时，对另一个类的影响也越大。 
解决方案：尽量降低类与类之间的耦合。（低耦合，高内聚）
		   只与直接的朋友通信。
		   直接的朋友：出现成员变量、方法参数、方法返回值中的类
		   非直接的朋友：出现在局部变量中的类则不是直接的朋友。也就是说，陌生的类最好不要作为局部变量的形式出现在类的内部。
优点          ：低耦合，高内聚	
缺点          ：过分的使用迪米特原则，会产生大量这样的中介和传递类。


名称          ：开闭（对扩展开放，对修改关闭）
定义          ：一个软件实体如类、模块和函数应该对扩展开放，对修改关闭。 
问题由来： 在软件的生命周期内，因为变化、升级和维护等原因需要对软件原有代码进行修改时，可能会给旧代码中引入错误，也可能会使我们不得不对整个功能进行重构，并且需要原有代码经过重新测试。
解决方案：当软件需要变化时，尽量通过扩展软件实体的行为来实现变化，而不是通过修改已有的代码来实现变化。
优点          ：建立稳定灵活的系统。 用抽象构建框架，用实现扩展细节。


------------------------------------------------------------------
			单例
定义：确保一个类只有一个实例，而且自行实例化并向整个系统提供这个实例。
类型：创建类模式 
分类：根据实例化对象时机的不同分为两种：一种是饿汉式单例，一种是懒汉式单例。
类图：
优点：
    在内存中只有一个对象，节省内存空间。
    避免频繁的创建销毁对象，可以提高性能。
    避免对共享资源的多重占用。
适用场景：
    需要频繁实例化然后销毁的对象。
    创建对象时耗时过多或者耗资源过多，但又经常用到的对象。
    有状态的工具类对象。
    频繁访问数据库或文件的对象。
    以及其他我没用过的所有要求只有一个对象的场景。
注意事项：
    只能使用单例类提供的方法得到单例对象，不要使用反射，否则将会实例化一个新对象。
    不要做断开单例类对象与类中静态引用的危险操作。
    多线程使用单例使用共享资源时，注意线程安全问题。
    
饿汉式单例好还是懒汉式单例好
        在java中，饿汉式单例要优于懒汉式单例。C++中则一般使用懒汉式单例。
单例类可以被继承吗
        饿汉式单例和懒汉式单例由于构造方法是private的，所以他们都是不可继承的，但是其他很多单例模式是可以继承的，例如登记式单例。
单例模式只有饿汉式和懒汉式两种吗
        饿汉式单例和懒汉式单例只是两种比较主流和常用的单例模式方法，从理论上讲，任何可以实现一个类只有一个实例的设计模式，都可以称为单例模式。
 在分布式系统、多个类加载器、以及序列化的的情况下，会产生多个单例，这一点是无庸置疑的。               
        
			工厂方法       
定义:一个用于创建对象的接口，让子类决定实例化哪一个类，工厂方法使一个类的实例化延迟到其子类
体现原则：迪米特法则
类型：创建类模式
分类：工厂模式根据抽象程度的不同分为三种：
类图：
工厂方法模式有四个要素：工厂接口。工厂实现。产品接口。产品实现。
优点：
	可以使代码结构清晰，有效地封装变化。
	对调用者屏蔽具体的产品类。
	降低耦合度。
适用场景：   
	生成复杂对象的地方，都可以使用工厂方法模式。
	简单对象，特别是只需要通过new就可以完成创建的对象，无需使用工厂模式。如果使用工厂模式，就需要引入一个工厂类，会增加系统的复杂度。
	解耦模式，迪米特法则在工厂模式中表现的尤为明显。假如调用者自己组装产品需要增加依赖关系时，可以考虑使用工厂模式。将会大大降低对象之间的耦合度。
	依靠抽象架构的，它把实例化产品的任务交由实现类完成，扩展性比较好。
	可以看到，调用者为了组装汽车还需要另外实例化发动机、底盘和轮胎，而这些汽车的组件是与调用者无关的，严重违反了迪米特法则，耦合度太高。并且非常不利于扩展。另外，本例中发动机、底盘和轮胎还是比较具体的，在实际应用中，可能这些产品的组件也都是抽象的，调用者根本不知道怎样组装产品。假如使用工厂方法的话，整个架构就显得清晰了许多。
	 使用工厂方法后，调用端的耦合度大大降低了。并且对于工厂来说，是可以扩展的，以后如果想组装其他的汽车，只需要再增加一个工厂类的实现就可以。无论是灵活性还是稳定性都得到了极大的提高。
	 

			抽象工厂 
定义:为创建一组相关或相互依赖的对象提供一个接口，而且无需指定他们的具体类。
体现原则：
类型：创建类模式
抽象工厂模式与工厂方法模式的区别:
	抽象工厂模式是工厂方法模式的升级版本，他用来创建一组相关或者相互依赖的对象。他与工厂方法模式的区别就在于，工厂方法模式针对的是一个产品等级结构；而抽象工厂模式则是针对的多个产品等级结构即产品族。产品族：指位于不同产品等级结构中功能相关联的产品组成的家族。
优点：
	抽象工厂模式除了具有工厂方法模式的优点外，最主要的优点就是可以在类的内部对产品族进行约束。
缺点：
	 产品族的扩展将是一件十分费力的事情，假如产品族中需要增加一个新的产品，则几乎所有的工厂类都需要进行修改。所以使用抽象工厂模式时，对产品等级结构的划分是非常重要的。
适用场景： 
	 当需要创建的对象是一系列相互关联或相互依赖的产品族时，便可以使用抽象工厂模式。(一个继承体系中，如果存在着多个等级结构（即存在着多个抽象类），并且分属各个等级结构中的实现类之间存在着一定的关联或者约束，就可以使用抽象工厂模式。)  
总结：
	无论是简单工厂模式，工厂方法模式，还是抽象工厂模式，他们都属于工厂模式，在形式和特点上也是极为相似的，他们的最终目的都是为了解耦。在使用时，我们不必去在意这个模式到底工厂方法模式还是抽象工厂模式，因为他们之间的演变常常是令人琢磨不透的。经常你会发现，明明使用的工厂方法模式，当新需求来临，稍加修改，加入了一个新方法后，由于类中的产品构成了不同等级结构中的产品族，它就变成抽象工厂模式了；而对于抽象工厂模式，当减少一个方法使的提供的产品不再构成产品族之后，它就演变成了工厂方法模式。
            所以，在使用工厂模式时，只需要关心降低耦合度的目的是否达到了。
            
			建造者
定义:将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示
体现原则：
类型：创建类模式
类图：
四个要素：
	产品类：一般是一个较为复杂的对象，也就是说创建对象的过程比较复杂，一般会有比较多的代码量。实际编程中，产品类可以是由一个抽象类与它的不同实现组成，也可以是由多个抽象类与他们的实现组成。
	抽象建造者：引入抽象建造者的目的，是为了将建造的具体过程交与它的子类来实现。这样更容易扩展。一般至少会有两个抽象方法，一个用来建造产品，一个是用来返回产品。
	建造者：一般是两项任务：组建产品；返回组建好的产品。
	导演类：负责调用适当的建造者来组建产品，导演类一般不与产品类发生依赖关系，与导演类直接交互的是建造者类。一般来说，导演类被用来封装程序中易变的部分。
优点：
	建造者模式的封装性很好。将主要的业务逻辑封装在导演类中对整体而言可以取得比较好的稳定性。
	建造者模式很容易进行扩展。如果有新的需求，通过实现一个新的建造者类就可以完成，基本上不用修改之前已经测试通过的代码，因此也就不会对原有功能引入风险。
建造者模式与工厂模式的区别：
	建造者模式与工厂模式是极为相似的，总体上，建造者模式仅仅只比工厂模式多了一个“导演类”的角色。在建造者模式的类图中，假如把这个导演类看做是最终调用的客户端，那么图中剩余的部分就可以看作是一个简单的工厂模式了。
	与工厂模式相比，建造者模式一般用来创建更为复杂的对象，因为对象的创建过程更为复杂，因此将对象的创建过程独立出来组成一个新的类——导演类。一般来说，如果产品的建造很复杂，那么请用工厂模式；如果产品的建造更复杂，那么请用建造者模式。	
缺点：

			原型
定义:用原型实例指定创建对象的种类，并通过拷贝这些原型创建新的对象。
体现原则：
类型：创建类模式
类图：
	原型模式主要用于对象的复制。核心是原型类Prototype。Prototype类需要具备以下两个条件：
	实现Cloneable接口。
	重写Object类中的clone方法。	
优点：	
	用原型模式创建对象比直接new一个对象在性能上要好的多，因为Object类的clone方法是一个本地方法，它直接操作内存中的二进制流，特别是复制大对象时，性能的差别非常明显。
	使用原型模式的另一个好处是简化对象的创建，使得创建对象就像我们在编辑文档时的复制粘贴一样简单。
使用场景:
	需要重复地创建相似对象时可以考虑使用原型模式。	
缺点：
注意事项:
	使用原型模式复制对象不会调用类的构造方法。单例模式与原型模式是冲突的，在使用时要特别注意。
	深拷贝与浅拷贝。如果要实现深拷贝，必须将原型模式中的数组、容器对象、引用对象等另行拷贝。
	
			总结
定义：创建类模式主要关注对象的创建过程，将对象的创建过程进行封装，使客户端可以直接得到对象，而不用去关心如何创建对象。
分类：
	 单例模式：用于得到内存中的唯一对象。
	 工厂方法模式：用于创建复杂对象。
	 抽象工厂模式：用于创建一组相关或相互依赖的复杂对象。
	 建造者模式：用于创建模块化的更加复杂的对象。
	 原型模式：用于得到一个对象的拷贝。
优点：
	将组装对象的过程封装到一个单独的类中，这样，既不会增加对象间的耦合，又可以最大限度的减小客户端的负担。	 				
	使用普通的方式创建对象，一般都是返回一个具体的对象，即所谓的面向实现编程，这与设计模式原则是相违背的。采用创建类模式则可以实现面向抽象编程。客户端要求的只是一个抽象的类型，具体返回什么样的对象，由创建者来决定。
	可以对创建对象的过程进行优化，客户端关注的只是得到对象，对对象的创建过程则不关心。      
本质：是对对象的创建过程进行封装。    

			模板方法
定义:定义一个操作中算法的框架，而将一些步骤延迟到子类中，使得子类可以不改变算法的结构即可重定义该算法中的某些特定步骤。
体现原则：开闭原则
类型：行为类
类图：
	模版方法模式由一个抽象类和一个（或一组）实现类通过继承结构组成，抽象类中的方法分为三种：
		抽象方法：父类中只声明但不加以实现，而是定义好规范，然后由它的子类去实现。
		模版方法：由抽象类声明并加以实现。一般来说，模版方法调用抽象方法来完成主要的逻辑功能，并且，模版方法大多会定义为final类型，指明主要的逻辑功能在子类中不能被重写。
		钩子方法：由抽象类声明并加以实现。但是子类可以去扩展，子类可以通过扩展钩子方法来影响模版方法的逻辑。
优点：	
	容易扩展。
	便于维护。
	比较灵活。
	因为有钩子方法，因此，子类的实现也可以影响父类中主逻辑的运行。违反了里氏替换原则。
使用场景:
	在多个子类拥有相同的方法，并且这些方法逻辑相同时，可以考虑使用模版方法模式。
	在程序的主框架相同，细节不同的场合下，也比较适合使用这种模式。
缺点：
注意事项:

			中介者
定义:用一个中介者对象封装一系列的对象交互，中介者使各对象不需要显示地相互作用，从而使耦合松散，而且可以独立地改变它们之间的交互。
体现原则：开闭原则
类型：行为类
类图：
	中介者模式又称为调停者模式。
	抽象中介者：定义好同事类对象到中介者对象的接口，用于各个同事类之间的通信。一般包括一个或几个抽象的事件方法，并由子类去实现。
	中介者实现类：从抽象中介者继承而来，实现抽象中介者中定义的事件方法。从一个同事类接收消息，然后通过消息影响其他同时类。
	同事类：如果一个对象会影响其他的对象，同时也会被其他对象影响，那么这两个对象称为同事类。
优点：	
	可以避免同事类之间的过度耦合，使得各同事类之间可以相对独立地使用。
	可以将对象间一对多的关联转变为一对一的关联，使对象间的关系易于理解和维护。
	可以将对象的行为和协作进行抽象，能够比较灵活的处理对象间的相互作用。
使用场景:
	 一般来说，同事类之间的关系是比较复杂的，多个同事类之间互相关联时，他们之间的关系会呈现为复杂的网状结构，这是一种过度耦合的架构，即不利于类的复用，也不稳定。
	 如果引入中介者模式，那么同事类之间的关系将变为星型结构，减小系统的耦合。大多数情况下，将对象间的依赖关系封装的同事类内部就可以的，没有必要非引入中介者模式。滥用中介者模式，只会让事情变的更复杂。
缺点：
注意事项:		

			观察者
定义:定义对象间一种一对多的依赖关系，使得当每一个对象改变状态，则所有依赖于它的对象都会得到通知并自动更新。
体现原则：
类型：行为类
类图：
	结构包括以下四个角色：
		被观察者：从类图中可以看到，类中有一个用来存放观察者对象的Vector容器这个Vector容器是被观察者类的核心，另外还有三个方法：attach方法是向这个容器中添加观察者对象；detach方法是从容器中移除观察者对象；notify方法是依次调用观察者对象的对应方法。
		观察者：观察者角色一般是一个接口，它只有一个update方法，在被观察者状态发生变化时，这个方法就会被触发调用。
		具体的被观察者：使用这个角色是为了便于扩展，可以在此角色中定义具体的业务逻辑。
		具体的观察者：观察者接口的具体实现，在这个角色中，将定义被观察者对象状态发生变化时所要处理的逻辑。
优点：
	观察者与被观察者之间是属于轻度的关联关系，并且是抽象耦合的，这样，对于两者来说都比较容易进行扩展。
	观察者模式是一种常用的触发机制，它形成一条触发链，依次对各个观察者的方法进行处理。	
使用场景:
缺点：
	由于是链式触发，当观察者比较多的时候，性能问题是比较令人担忧的。并且，在链式结构中，比较容易出现循环引用的错误，造成系统假死。
注意事项:		

			访问者
定义:封装某些作用于某种数据结构中各元素的操作，它可以在不改变数据结构的前提下定义作用于这些元素的新的操作。
体现原则：
类型：行为类
类图：
	抽象访问者：抽象类或者接口，声明访问者可以访问哪些元素，具体到程序中就是visit方法中的参数定义哪些对象是可以被访问
	访问者：实现抽象访问者所声明的方法，它影响到访问者访问到一个类后该干什么，要做什么事情。
	抽象元素类：接口或者抽象类，声明接受哪一类访问者访问，程序上是通过accept方法中的参数来定义的。抽象元素一般有两类方法，一部分是本身的业务逻辑，另外就是允许接收哪类访问者来访问。
	元素类：实现抽象元素类所声明的accept方法，通常都是visitor.visit(this)，基本上已经形成一种定式了。
	结构对象：一个元素的容器，一般包含一个容纳多个不同类、不同接口的容器，如List、Set、Map等，在项目中一般很少抽象出这个角色。
优点：
	单一职责。
	扩展性良好。元素类可以通过接受不同的访问者来实现对不同操作的扩展。
使用场景:
	假如一个对象中存在着一些与本对象不相干（或者关系较弱）的操作，为了避免这些操作污染这个对象，则可以使用访问者模式来把这些操作封装到访问者中去。
缺点：
	问者模式并不是那么完美，它也有着致命的缺陷：增加新的元素类比较困难。通过访问者模式的代码可以看到，在访问者类中，每一个元素类都有它对应的处理方法，也就是说，每增加一个元素类都需要修改访问者类（也包括访问者类的子类或者实现类），修改起来相当麻烦。
注意事项:
总结：
	在现实情况下（至少是我所处的环境当中），很多人往往沉迷于设计模式，他们使用一种设计模式时，从来不去认真考虑所使用的模式是否适合这种场景，而往往只是想展示一下自己对面向对象设计的驾驭能力。编程时有这种心理，往往会发生滥用设计模式的情况。所以，在学习设计模式时，一定要理解模式的适用性。必须做到使用一种模式是因为了解它的优点，不使用一种模式是因为了解它的弊端；而不是使用一种模式是因为不了解它的弊端，不使用一种模式是因为不了解它的优点。
	
			命令
定义:将一个请求封装成一个对象，从而让你使用不同的请求把客户端参数化，对请求排队或者记录请求日志，可以提供命令的撤销和恢复功能。
体现原则：
类型：行为类
类图：
	命令模式就是对命令的封装。
		Command类：是一个抽象类，类中对需要执行的命令进行声明，一般来说要对外公布一个execute方法用来执行命令。
		ConcreteCommand类：Command类的实现类，对抽象类中声明的方法进行实现。
		Client类：最终的客户端调用类。
		Invoker类：调用者，负责调用命令。
		Receiver类：接收者，负责接收命令并且执行命令。
优点：
	命令模式的封装性很好。
	命令模式的扩展性很好。
使用场景:
	对于大多数请求-响应模式的功能，比较适合使用命令模式，正如命令模式定义说的那样，命令模式对实现记录日志、撤销操作等功能比较方便。
缺点：
	命令如果很多，开发起来就要头疼了。特别是很多简单的命令，实现起来就几行代码的事，而使用命令模式的话，不用管命令多简单，都需要写一个命令类来封装。
注意事项:
总结：
	我们开发中，请求-响应模式的功能非常常见，一般来说，我们会把对请求的响应操作封装到一个方法中，这个封装的方法可以称之为命令，但不是命令模式。到底要不要把这种设计上升到模式的高度就要另行考虑了，因为，如果使用命令模式，就要引入调用者、接收者两个角色，原本放在一处的逻辑分散到了三个类中，设计时，必须考虑这样的代价是否值得。
		
			责任链
定义:使多个对象都有机会处理请求，从而避免了请求的发送者和接收者之间的耦合关系。将这些对象连成一条链，并沿着这条链传递该请求，直到有对象处理它为止。
体现原则：
类型：行为类
类图：
	由一个抽象地处理类和它的一组实现类组成：
		抽象处理类：抽象处理类中主要包含一个指向下一处理类的成员变量nextHandler和一个处理请求的方法handRequest，handRequest方法的主要主要思想是，如果满足处理的条件，则有本处理类来进行处理，否则由nextHandler来处理。
		具体处理类：具体处理类主要是对具体的处理逻辑和处理的适用条件进行实现。
优点：
	责任链模式与if…else…相比，他的耦合性要低一些
	假如使用if…else…语句来组织一个责任链时感到力不从心，代码看上去很糟糕时，就可以使用责任链模式来进行重构。
使用场景:
	代码臃肿
	耦合度高
缺点：
	搞对处理类前后逻辑的条件判断关系，并且注意不要在链中出现循环引用的问题。
注意事项:
总结：

			策略
定义:定义一组算法，将每个算法都封装起来，并且使他们之间可以互换。
体现原则：
类型：行为类
类图：
	封装类：也叫上下文，对策略进行二次封装，目的是避免高层模块对策略的直接调用。
	抽象策略：通常情况下为一个接口，当各个实现类中存在着重复的逻辑时，则使用抽象类来封装这部分公共的代码，此时，策略模式看上去更像是模版方法模式。
	具体策略：具体策略角色通常由一组封装了算法的类来担任，这些类之间可以根据需要自由替换。
优点：
	策略类之间可以自由切
	易于扩展
	避免使用多重条件
使用场景:
	几个类的主要逻辑相同，只在部分逻辑的算法和行为上稍有区别的情况。
	有几种相似的行为，或者说算法，客户端需要动态地决定使用哪一种，那么可以使用策略模式，将这些算法封装起来供客户端调用。
缺点：
	维护各个策略类会给开发带来额外开销，可能大家在这方面都有经验：一般来说，策略类的数量超过5个，就比较令人头疼了。
	必须对客户端（调用者）暴露所有的策略类
注意事项:
总结：
		
			迭代器
定义:提供一种方法访问一个容器对象中各个元素，而又不暴露该对象的内部细节。
体现原则：
类型：行为类
类图：
	抽象容器：一般是一个接口，提供一个iterator()方法
	具体容器：就是抽象容器的具体实现类
	抽象迭代器：定义遍历元素所需要的方法，一般来说会有这么三个方法：取得第一个元素的方法first()，取得下一个元素的方法next()，判断是否遍历结束的方法isDone()（或者叫hasNext()），移出当前对象的方法remove(),
	迭代器实现：实现迭代器接口中定义的方法，完成集合的迭代。
优点：
	简化了遍历方式，对于对象集合的遍历，还是比较麻烦的，对于数组或者有序列表，我们尚可以通过游标来取得，但用户需要在对集合了解很清楚的前提下，自行遍历对象，但是对于hash表来说，用户遍历起来就比较麻烦了。而引入了迭代器方法后，用户用起来就简单的多了。	
	可以提供多种遍历方式，可以根据需要提供正序遍历，倒序遍历两种迭代器
	封装性良好，用户只需要得到迭代器就可以遍历，而对于遍历算法则不用去关心。
	
使用场景:
缺点：
	对于比较简单的遍历（像数组或者有序列表），使用迭代器方式遍历较为繁琐
注意事项:
总结：

			解释器
定义:给定一种语言，定义他的文法的一种表示，并定义一个解释器，该解释器使用该表示来解释语言中句子。
体现原则：
类型：行为类
类图：
	抽象解释器：声明一个所有具体表达式都要实现的抽象接口（或者抽象类），接口中主要是一个interpret()方法，称为解释操作。具体解释任务由它的各个实现类来完成，具体的解释器分别由终结符解释器TerminalExpression和非终结符解释器NonterminalExpression完成。
	终结符表达式：实现与文法中的元素相关联的解释操作，通常一个解释器模式中只有一个终结符表达式，但有多个实例，对应不同的终结符。终结符一半是文法中的运算单元，比如有一个简单的公式R=R1+R2，在里面R1和R2就是终结符，对应的解析R1和R2的解释器就是终结符表达式。      
	非终结符表达式：文法中的每条规则对应于一个非终结符表达式，非终结符表达式一般是文法中的运算符或者其他关键字，比如公式R=R1+R2中，+就是非终结符，解析+的解释器就是一个非终结符表达式。非终结符表达式根据逻辑的复杂程度而增加，原则上每个文法规则都对应一个非终结符表达式。
	环境角色：这个角色的任务一般是用来存放文法中各个终结符所对应的具体值，比如R=R1+R2，我们给R1赋值100，给R2赋值200。这些信息需要存放到环境角色中，很多情况下我们使用Map来充当环境角色就足够了。
优点：
	解释器是一个简单的语法分析工具，它最显著的优点就是扩展性，修改语法规则只需要修改相应的非终结符就可以了，若扩展语法，只需要增加非终结符类就可以了。
	类文件多，难维护
	大量的循环和递归，效率低
使用场景:
	有一个简单的语法规则，比如一个sql语句，如果我们需要根据sql语句进行rm转换，就可以使用解释器模式来对语句进行解释。
	一些重复发生的问题，比如加减乘除四则运算，但是公式每次都不同，有时是a+b-c*d，有时是a*b+c-d，等等等等个，公式千变万化，但是都是由加减乘除四个非终结符来连接的，这时我们就可以使用解释器模式。
缺点：
注意事项:
总结：

			状态
定义:
体现原则：
类型：行为类
类图：
	上下文环境（Context）：它定义了客户程序需要的接口并维护一个具体状态角色的实例，将与状态相关的操作委托给当前的Concrete State对象来处理。
	抽象状态（State）：定义一个接口以封装使用上下文环境的的一个特定状态相关的行为。
	具体状态（Concrete State）：实现抽象状态定义的接口。
优点：
	状态模式将与特定状态相关的行为局部化，并且将不同状态的行为分割开来。
	所有状态相关的代码都存在于某个ConcereteState中，所以通过定义新的子类很容易地增加新的状态和转换。
	状态模式通过把各种状态转移逻辑分不到State的子类之间，来减少相互间的依赖。
使用场景:
	主要解决的是当控制一个对象状态转换的条件表达式过于复杂时的情况。把状态的判断逻辑转移到表示不同的一系列类当中，可以把复杂的逻辑判断简单化。
	当一个对象的行为取决于它的状态，并且它必须在运行时刻根据状态改变它的行为时，就可以考虑使用状态模式来。
	一个操作中含有庞大的分支结构，并且这些分支决定于对象的状态。
缺点：
	导致较多的ConcreteState子类
注意事项:
总结：

			总结

			备忘录
定义:在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样就可以将该对象恢复到原先保存的状态
体现原则：
类型：结构类
类图：
	发起人：记录当前时刻的内部状态，负责定义哪些属于备份范围的状态，负责创建和恢复备忘录数据。
	备忘录：负责存储发起人对象的内部状态，在需要的时候提供发起人需要的内部状态。
	管理角色：对备忘录进行管理，保存和提供备忘录。
	多状态多备份备忘录
优点：
	当发起人角色中的状态改变时，有可能这是个错误的改变，我们使用备忘录模式就可以把这个错误的改变还原。
	备份的状态是保存在发起人角色之外的，这样，发起人角色就不需要对各个备份的状态进行管理。
使用场景:
缺点：
	在实际应用中，备忘录模式都是多状态和多备份的，发起人角色的状态需要存储到备忘录对象中，对资源的消耗是比较严重的。
注意事项:
总结：

			桥梁
定义:将抽象化与实现化脱耦，使得二者可以独立地变化。
体现原则：
类型：结构类
类图：
	抽象化(Abstraction)角色：抽象化给出的定义，并保存一个对实现化对象的引用。
	修正抽象化(RefinedAbstraction)角色：扩展抽象化角色，改变和修正父类对抽象化的定义。
	实现化(Implementor)角色：这个角色给出实现化角色的接口，但不给出具体的实现。必须指出的是，这个接口不一定和抽象化角色的接口定义相同，实际上，这两个接口可以非常不一样。实现化角色应当只给出底层操作，而抽象化角色应当只给出基于底层操作的更高一层的操作。
	具体实现化(ConcreteImplementor)角色：这个角色给出实现化角色接口的具体实现。
优点：
	分离抽象和实现部分
	更好的扩展性
使用场景:
	业务的变化具有两个维度，一个维度是抽象的消息，包括普通消息、加急消息和特急消息，这几个抽象的消息本身就具有一定的关系，加急消息和特急消息会扩展普通消息；另一个维度是在具体的消息发送方式上，包括系统内短消息、邮件和手机短消息，这几个方式是平等的，可被切换的方式。
缺点：
注意事项:
总结：
		
			适配器
定义:
体现原则：
类型：结构类
类图：
	1.类的适配器模式（采用继承实现）
    2.对象适配器（采用对象组合方式实现）
    Target：定义Client使用的与特定领域相关的接口。
    Client：与符合Target接口的对象协同。
    Adaptee：定义一个已经存在的接口，这个接口需要适配。
    Adapter：对Adaptee的接口与Target接口进行适配
    
优点：
使用场景:
	专用来在系统后期扩展、修改时所用。
缺点：
注意事项:
总结：
		
			代理						
定义:为其他对象提供一种代理，并以控制对这个对象的访问。
体现原则：
类型：结构类
类图：
	1) 远程代理（Remote  Proxy）为一个位于不同的地址空间的对象提供一个本地的代理对象。这个不同的地址空间可以是在同一台主机中，也可是在另一台主机中，远程代理又叫做大使(Ambassador)
	2) 虚拟代理（Virtual Proxy）根据需要创建开销很大的对象。如果需要创建一个资源消耗较大的对象，先创建一个消耗相对较小的对象来表示，真实对象只在需要时才会被真正创建。 
	3) 保护代理（Protection Proxy）控制对原始对象的访问。保护代理用于对象应该有不同的访问权限的时候。
	4) 智能指引（Smart Reference）取代了简单的指针，它在访问对象时执行一些附加操作。
	5) Copy-on-Write代理：它是虚拟代理的一种，把复制（克隆）操作延迟到只有在客户端真正需要时才执行。一般来说，对象的深克隆是一个开销较大的操作，Copy-on-Write代理可以让这个操作延迟，只有对象被用到的时候才被克隆。
		代理角色(Proxy):保存一个引用使得代理可以访问实体。
			Remote Proxy：负责对请求及其参数进行编码，并向不同地址空间中的实体发送已编码的请求。
			Virtual Proxy：可以缓存实体的附加信息，以便延迟对它的访问。
			Protection Proxy：检查调用者是否具有实现一个请求所必需的访问权限。
		 抽象主题角色(Subject):定义真实主题角色RealSubject 和 抽象主题角色Proxy的共用接口，这样就在任何使用RealSubject的地方都可以使
		 真实主题角色(RealSubject):定义了代理角色(proxy)所代表的具体对象. 
用Proxy。
优点：
	代理模式能够协调调用者和被调用者，在一定程度上降低了系统的耦合度。
使用场景:
缺点：
	处理速度变慢。
	实现代理模式需要额外的工作，有些代理模式的实现非常复杂。 
注意事项:
总结：
    "增加一层间接层"是软件系统中对许多负责问题的一种常见解决方法。在面向对象系统中，直接使用某些对象会带来很多问题，作为间接层的proxy对象便是解决这一问题的常用手段。
           具体proxy设计模式的实现方法、实现粒度都相差很大，有些可能对单个对象作细粒度的控制，有些可能对组件模块提供抽象代理层，在架构层次对对象作proxy。
    proxy并不一定要求保持接口的一致性，只要能够实现间接控制，有时候损及一些透明性是可以接受的。例如上面的那个例子，代理类型ProxyClass和被代理类型LongDistanceClass可以不用继承自同一个接口，正像GoF《设计模式》中说的：为其他对象提供一种代理以控制这个对象的访问。代理类型从某种角度上讲也可以起到控制被代理类型的访问的作用。
	
		
			享元		
定义:对象结构型模式运用共享技术有效地支持大量细粒度的对象。
体现原则：
类型：结构类
类图：
	单纯享元模式和复合享元模式两种形式。
	抽象享元类(Flyweight): 描述一个接口，通过这个接口flyweight可以接受并作用于外部状态。
	具体享元类(ConcreteFlyweight):实现Flyweight接口 ，并为内部状态（ 如果有的话 )增加存储空间 。ConcreteFlyweight对象必须是可共享的。它所存储的状态必须是内部的；即，它必须独立于ConcreteFlyweight对象的场景。
	非共享具体享元类(UnsharedConcreteFlyweight)： 并非所有的Flyweight子类都需要被共享。Flyweight接口使共享成为可能，但它并不强制共享。在Flyweight对象结构的某些层次，UnsharedConcreteFlyweight对象通常将ConcreteFlyweight对象作为子节点。
	享元工厂类(FlyweightFactory):创建并管理flyweight对象, 确保合理地共享flyweight。本角色必须保证享元对象可以被系统适当地共享。当一个客户端对象调用一个享元对象 
	客户（Client）:维持一个对flyweight的引用。计算或存储一个（多个）flyweight的外部状态。
优点：
	极大减少内存中对象的数量
	享元对象可以在不同的环境中被共享。
使用场景:
	   一个应用程序使用大量相同或者相似的对象，造成很大的存储开销。
	  对象的大部分状态都可以外部化，可以将这些外部状态传入对象中。
	  如果删除对象的外部状态，那么可以用相对较少的共享对象取代很多组对象。
            应用程序不依赖于对象标识。由于Flyweight对象可以被共享，对于概念上明显有别的对象，标识测试将返回真值。
	 使用享元模式需要维护一个存储享元对象的享元池，而这需要耗费资源，因此，应当在多次重复使用享元对象时才值得使用享元模式。
缺点：
	需要分离出内部状态和外部状态，这使得程序的逻辑复杂化。
	需要将享元对象的状态外部化，而读取外部状态使得运行时间变长。
注意事项:
总结：
		
			装饰器					
定义:就是动态地给一个对象添加一些额外的职责，就好比为房子进行装修一样。
体现原则：
类型：结构类
类图：
	1.被装饰对象（Bread）
	2.装饰对象
	3.装饰器（Decorator）	
	4.公共接口或抽象类（Ingredient）
优点：
	装饰模式与继承关系的目的都是要扩展对象的功能，但是装饰模式可以提供比继承更多的灵活性。装饰模式允许系统动态决定“贴上”一个需要的“装饰”，或者除掉一个不需要的“装饰”。继承关系则不同，继承关系是静态的，它在系统运行前就决定了。
	通过使用不同的具体装饰类以及这些装饰类的排列组合，设计师可以创造出很多不同行为的组合。
使用场景:
	1、当我们需要为某个现有的对象，动态的增加一个新的功能或职责时，可以考虑使用装饰模式。
	2、适应于某个对象的职责经常发生变化或者经常需要动态的增加职责，避免因为这种为了适应这样的变化，而增加继承子类扩展的方式，因为这种方式为 造成，子类膨胀的速度过快，难以控制。
	1、  想透明并且动态地给对象增加新的职责的时候。
	2、  给对象增加的职责，在未来存在增加或减少可能。

3、  用继承扩展功能不太现实的情况下，应该考虑用组合的方式。
缺点：
	可以用无数个装饰者包装一个组件，装饰者类会导致设计中出现许多小对象，过度使用会让程序变的复杂
	装饰者一般对组件的客户是透明的，除非客户程序依赖于组件的具体类型
注意事项:
总结：
	1，继承属于扩展形式之一，但不见得是达到弹性设计的最佳方式。
	2，在我们的设计中，应该允许行为可以被扩展，而无须修改现在的代码。
	3，组合和委托可用于在运行动态地加上新的行为。
	4，除了继承，装饰者模式也可以让我们扩展行为。
	5，装饰者模式意味着一群装饰者类，这些类用来包装具体组件。
	6，装饰者类反映出被装饰者的组件类型（事实上，他们具有相同的类型，都经过接口或继承实现）。
	7，装饰者可以在被装饰者的行为前面与/或后面加上自己的行为，甚至将被装饰者的行为整个取代掉，而达到特定的目的。
	8，你可以用无数个张世哲包装一个组件。
	9，装饰者一般对组件的客户透明的，除非客户程序依赖于组件的具体类型。
	10，装饰者会导致设计中出现许多小对象，如果过度使用，会让程序变得很复杂。





//=========================================================================================================
OO原则：
分开变化和不会变化的部分(抽出变化的部分-取出易于变化的部分)
	找出应用中可能需要变化之处，把它们独立出来，不要和那些不需要变化的代码混在一起
	结果：代码变化引起的不经意后果变少，系统变得更有弹性
针对接口编程而不是针对实现编程
	什么是针对实现编程
	在运行时想改变鸭子的行为，只需调用鸭子的setter方法就可以(运行是动态改变鸭子的行为)
多用组合，少用继承
	使用组合建立系统具有很大的弹性，不仅可将算法族封装成类，更可以“在运行是动态地改变行为”，只要组合的行为对象符合正确的接口标准
	组合的优点和缺点
	策略模式：定义了算法族，分别封装起来，让他们之间可以相互替换，此模式让算法的变化独立于使用算法的客户
	(模拟鸭子应用-采用良好的OO软件设计原则)
	封装行为的大局观：IS-A，HAS-A
	共享模式词汇的威力

	OO基础：抽象，封装，多态，继承
	OO原则：封装变化;多用组合，少用继承;针对接口编程，不针对实现编程;为交互对象之间的松耦合设计而努力;类应该对扩展开放，对修改关闭;依赖抽象，不要依赖具体类;只和朋友交谈
	OO模式：策略,观察者,装饰者,抽象工厂,工厂方法,单件,命令,适配器,外观，
	
	知道OO基础概念，就能自动设计出弹性的，可复用的，可维护的系统?
	良好的OO设计必须具备可复用，可扩充，可维护三个特性
	模式可以让我们建造出具有良好OO设计质量的系统
	建立可维护的OO系统，要诀就在于随时想到系统以后可能需要的变化以及应付变化的原则
	装饰者模式：动态地将责任附加到对象上。想要扩展功能，装饰者提供有别于继承的另一种选择(扩展行为)
	抽象工厂模式：提供一个接口用于创建相关或依赖对象的家族，而不需要明确指定具体类
	工厂方法模式：定义了一个创建对象的接口，但由子类决定要实例化的类是哪一个。工厂方法让类把实例化推迟到子类
	单件模式：确保一个类只有一个实例，并提供全局的访问点
	命令模式：将请求封装成对象，这可以让你使用不同的请求，队列，或日志请求来参数化其他对象。命令模式也可以支持撤销操作
	适配器模式：将一个类的接口，转成客户期望的另一个接口。适配器让原来不兼容的类可以工作无间
	外观模式：提供了一个统一的接口，用来访问子系统的一群接口。外观定义了一个高层接口，让子系统更容易使用
设计原则：
	为交互对象之间的松耦合设计而努力。(松耦合的设计之所以能让我们建立弹性的OO系统，能够应对变化，是应为对象之间的相互依赖到了最低)
	类应该对扩展开放，对修改关闭(我们的目标是允许类容易扩展，在不修改现有代码的情况下，就可搭配新的行为，这样的设计具有弹性可以应对改变：区别类中变化和不变的地方)
	
	P77

指导方针：
避免在OO设计中违反依赖倒置原则：
变量不可以持有具体类的引用
不要让类派生自具体类
不要覆盖基类中以实现的方法

只和朋友交谈 指导方针：
该对象本身
被当做方法的参数而传递进来的对象
此方法所创建的或实例化的任何对象
对象的任何组件
 


对比：装饰器，适配器，外观
装饰器-将一个接口转成另一个接口
适配器-不改变接口，但责任
外观-让接口更简单
对比：对象适配器，类适配器
对象适配器使用对象组合
类适配器使用类继承
对比：依赖倒置，好莱坞原则
对比：训练中研究经典模式，荒野(Java API-Arrays中的sort方法数组拷贝和mergeSort排序，API中其他模板方法的例子)中的模板模式(到外面的真实世界，学会找出周围的模式，识别模式的变体)


启示：
对象运行时动态扩展行为
分离变化和不变，封装变化
工厂模式:解耦-工厂方法将客户和实际创建具体产品的代码分隔开来，框架


代码规范：
编码规范
1.实现注释和文档注释
	实现注释：/*...*/,//
	文档注释：/**...*/(javadoc->html)
2.一行一个声明，一行一个语句，有利于写注释
3.局部变量初始化
代码布局
4.if语句总带括号
5.空while语句：while(condition);
空白：空行，空格
6.空行：两方法之间；方法局部变量与方法第一语句之间；块，当行注释之前；一方法内的两逻辑段之间
命名规范
7.类：名词，完整的单词或被广泛使用的缩写词
8.方法：动词
9.变量：不以下划线，美元符号开头，简短且富于描述，尽量避免单个字符的变量名
10.实例变量：前加下划线
11.GUI组件：以组件类型缩写开头，遵循变量命名规范。eg:JButton btnConfirm;JTextField txtPassword;
编程惯例
12.实例及类变量访问控制
13.避免用一个对象访问一个类的静态变量和方法，应该用类名替代
14.赋值运算符与相等关系运算
if((c++=d++)!=0){
}
15.圆括号运算符优先级:(x>=0)?x:-x
16.返回值：return booleanExpression
17.FIXME标识某些错误的内容
18.一方法一功能，多个参数用一个对象或数组来替代
	
	
	
	
	
	
	
	
云形图标---<<type>>类---领域模型(逻辑)
	
	
	
敏捷开发：原则，模式，实践
单元测试，验收测试
需求变化-设计退化
TDD明确，分离职责 可以应对需求变化 
敏捷设计：P86（不能忍受代码腐化）
敏捷开发人员知道要做什么，是因为：
他们遵循敏捷实践去发现问题
他们应用设计原则去诊断问题；并且
他们知道应用适当的设计模式去解决问题
软件开发的这三个方面的相互作用就是设计。
OO设计原则：
SRP
OCP
封闭建立在抽象的基础上，多态-继承 
第一颗，二颗子弹
LSP
OOA基本技术之一：is-a
单元测试通过彻底的测试一个类的行为来使该类的行为更加清晰
P109
DIP
框架设计的原则；依赖终止于抽象类或者接口
ISP
接口污染；委托
设计原则：“自顶向下”，“自底向上”；消除依赖；演化；稳定程度度量；抽象性度量；
初期解决主要风险
装饰器模式的测试用例书写(P353,P73)-覆盖了所有情况-一套完整的测试用例集
模块三项职责：原则，模式创建更加灵活和具有适应性的软件模块；注意力；纪律约束；创造美的激情
	可运行，能完成功能；
	应对变化(几乎所有模块在它们的生命周期中都要变化，开发者有责任保证这种改变应该尽可能地简单)；
	要和阅读它的人进行沟通；
拙劣设计的症状：
	僵化性-设计难以改变
	脆弱性-设计易于遭到破坏
	牢固性-设计难以重用
	粘滞性-难以做正确事情
	不必要的复杂性-过分设计	
	晦涩性-混乱的表达
面向对象设计原则，有助于开发人员消除设计中的臭味并构建出最好的设计
	单一职责原则(SRP)
	开放-封闭原则(OCP)
	Liskov替换原则(LSP)
	依赖倒置原则(DIP)
	接口隔离原则(ISP)
	没有臭味时，不会应用这些原则(合理使用原则)


重构：
方法：public boolean judge(bolean bool){
	return bool==false;
      }
一个类只有一个引起它变化的原因

经典书籍：多读,多花时间精读，细心写博客(设计模式，重构等经典技术，思想)(分析，设计，目标，结果，原则，模式)
设计：时间流程图-模块结构图
代码快照(snapshot)


二叉树试题
栈排二叉树编程
常用算法编程
阅读C++教程
英语语法	



UML与模式
初始化阶段P94
细化阶段P95
问题：
P100



数据驱动-防止变异-对修改关闭，对扩张开放



领域驱动设计：
值对象不可变，安全类似String类
查询模型；领域层（领域模型）-命令模型



===========================================================================================================================================================================
Internet组成：
	边缘部分
	核心部分	路由器实现分组交换
		电路交换的特点：建立连接-通话-释放连接
		分组交换的特点：采用存储转发技术
			报文：要发送的整块数据。分组，包，首部
		比较：电路交换，报文交换，分组交换

计算机性能指标：速率-比特，数据率；带宽；吞吐量；时延：发送时延(计算公式)，传播时延(计算公式)，处理时延，排队时延
===========================================================================================================================================================================



























































